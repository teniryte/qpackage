#!/usr/bin/env node
// @ts-nocheck
'use strict';

const fs = require('fs');
const path = require('path');
const readline = require('readline');
const childProcess = require('child_process');

start()
  .then(() => {})
  .catch(err => console.log('Error:', err));

async function start() {  
  let options = await getOptions();

  createDir(options);
  createPackage(options);
  createFiles(options);
  createBin(options);
  createLib(options);
  createTest(options);
  installDependencies(options);
  setupRepository(options);

  process.exit(0);
}

async function getOptions() {
  let rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  }),
  defaultOptions = getDefaultOptions(),
  name = await question('Package name', process.argv[2]),
  argvDependencies = process.argv.slice(3),
  options = mergeOptions(defaultOptions, {
    parentDir: process.cwd(),
    name: name,
    scope: await question('Scope', defaultOptions.scope),
    authorUsername: await question(
      'Author username',
      defaultOptions.authorUsername
    ),
    authorEmail: await question(
      'Author email',
      defaultOptions.authorEmail
    ),
    year: (new Date()).getFullYear(),
    version: '0.0.1',
    description: await question('Description'),
    keywords: (await question('Keywords'))
      .split(' ')
      .map(word => word.trim())
      .filter(word => !!word),
    homepage: await question('Homepage'),
    license: await question('License', defaultOptions.LICENSE || 'MIT'),
    repository: await question(
      'Repository',
      `git@${defaultOptions.repo.host}:` +
        `${defaultOptions.repo.user}/` +
        `${name}.git`
    ),
    dependencies: argvDependencies.length
      ? argvDependencies
      : (await question('Dependencies'))
        .split(' ')
        .map(dep => dep.trim())
        .filter(dep => !!dep),
    bin: (await question('Bin (y/n)', false)) === 'y',
    publish: (await question('Publish y/n (n)')) === 'y',
    registry: await question('Registry', defaultOptions.registry),
  });

  return options;

  function question(question = '', defaultValue = '') {
    let message = `${question}${defaultValue ? ` (${defaultValue})` : ''}: `;
    return new Promise((resolve, reject) => {
      rl.question(message, value => {
        resolve(value || defaultValue || '');
      });
    });
  }
}

function setupRepository(options) {
  if (!options.repository) return options;
  let execOptions = {
      cwd: options.dir,
      stdio: 'inherit',
    },
    packageData = require(
      path.resolve(options.dir, 'package.json')
    ),
    version = packageData.version,
    commands = [
      `git init`,
      `git remote add origin ${options.repository}`,
      `git add . --all`,
      `git commit -m 'Init'`,
      `git push -u origin master`,
      options.publish ? `yarn publish --new-version ${version}` : null,
    ];
  commands.filter(command => !!command).forEach(command => {
    childProcess.execSync(command, execOptions);
  });
}

function installDependencies(options) {
  if (!options.dependencies.length) return options;
  childProcess.execSync(`yarn add ${options.dependencies.join(' ')}`, {
    cwd: path.resolve(options.dir),
    stdio: 'inherit',
  });
}

function createTest(options) {
  fs.mkdirSync(path.resolve(options.dir, 'test'));
  fs.writeFileSync(
    path.resolve(options.dir, `test/index.js`),
    `'use strict';\n`
  );
}

function createLib(options) {
  fs.mkdirSync(path.resolve(options.dir, 'lib'));
  fs.writeFileSync(
    path.resolve(options.dir, `lib/index.js`),
    `'use strict';\n\nmodule.exports = {\n\n};`
  );
}

function createBin(options) {
  if (!options.bin) return options;
  let filename = path.resolve(options.dir, `bin/${options.name}`);
  fs.mkdirSync(path.resolve(options.dir, 'bin'));
  fs.writeFileSync(
    filename,
    `#!/usr/bin/env node\n'use strict';\n`
  );
  fs.chmodSync(filename, 0o777);
}

function createFiles(options) {
  let files = fs.readdirSync(path.resolve(__dirname, '../template'));
  files.forEach(file => {
    fs.writeFileSync(
      path.resolve(options.dir, file),
      fs.readFileSync(
        path.resolve(__dirname, '../template', file),
        'utf-8'
      )
        .replace(/\{\{name\}\}/mgi, options.name)
        .replace(/\{\{description\}\}/mgi, options.description)
        .replace(/\{\{authorUsername\}\}/mgi, options.authorUsername)
        .replace(/\{\{authorEmail\}\}/mgi, options.authorEmail)
    );
  });
  fs.renameSync(
    path.resolve(options.dir, 'gitignore'),
    path.resolve(options.dir, '.gitignore')
  );
}

function createDir(options) {
  let dir = path.resolve(options.parentDir, options.name);
  if (fs.existsSync(dir)) {
    return console.log(`Directory «${dir}» already exists!`);
  }
  fs.mkdirSync(dir);
  options.dir = dir;
  return dir;
}

function createPackage(options) {
  let data = getPackage(options);
  fs.writeFileSync(
    path.resolve(options.dir, 'package.json'),
    JSON.stringify(data, null, 2)
  );
}

function getPackage(options) {
  let data = {
    name: options.scope ? `${options.scope}/${options.name}` : options.name,
    version: options.version,
    main: './lib/index.js',
    description: options.description,
    keywords: options.keywords,
    homepage: options.homepage,
    license: options.license,
    dependencies: {},
    devDependencies: {
      jest: '^26.6.3',
    },
    scripts: {
      'test': 'node ./node_modules/.bin/jest',
    },
    author: {
      'name': options.authorUsername,
      'email': options.authorEmail,
    },
    repository: {
      type: 'git',
      url: options.repository ||
        `git@${options.repo.host}:` +
          `${options.repo.user}/` +
          `${options.name}.git`
    },
    publish: !!options.publish,
    publishConfig: {
      registry: options.registry || 'http://registry.npmjs.org/'
    },
  };
  if (options.bin) {
    data.bin = {
      [options.name]: `./bin/${options.name}`
    };
  }
  return data;
}

function mergeOptions(...datas) {
  let options = {};
  datas.forEach(data => {
    Object.keys(data).forEach(key => {
      let value = data[key];
      if (!value) return;
      options[key] = value;
    });
  });
  return options;
}

function getDefaultOptions() {
  let options = {},
    dir = process.cwd();
  while (dir !== '/' && fs.existsSync(dir) && fs.statSync(dir).isDirectory()) {
    let filename = path.resolve(dir, '.qpackage.json');
    dir = path.resolve(dir, '..');
    if (!fs.existsSync(filename) || !fs.statSync(filename)) continue;
    Object.assign(options, require(filename));
  }
  return options;
}
